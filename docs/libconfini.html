<!DOCTYPE html>
<html>
<head>
  <meta http-equiv='content-type' value='text/html;charset=utf8'>
  <meta name='generator' value='Ronn/v0.7.3 (http://github.com/rtomayko/ronn/tree/0.7.3)'>
  <title>libconfini</title>
  <style type='text/css' media='all'>
  /* style: man */
  body#manpage {margin:0}
  .mp {max-width:100ex;padding:0 9ex 1ex 4ex}
  .mp p,.mp pre,.mp ul,.mp ol,.mp dl {margin:0 0 20px 0}
  .mp h2 {margin:10px 0 0 0}
  .mp > p,.mp > pre,.mp > ul,.mp > ol,.mp > dl {margin-left:8ex}
  .mp h3 {margin:0 0 0 4ex}
  .mp dt {margin:0;clear:left}
  .mp dt.flush {float:left;width:8ex}
  .mp dd {margin:0 0 0 9ex}
  .mp h1,.mp h2,.mp h3,.mp h4 {clear:left}
  .mp pre {margin-bottom:20px}
  .mp pre+h2,.mp pre+h3 {margin-top:22px}
  .mp h2+pre,.mp h3+pre {margin-top:5px}
  .mp img {display:block;margin:auto}
  .mp h1.man-title {display:none}
  .mp,.mp code,.mp pre,.mp tt,.mp kbd,.mp samp,.mp h3,.mp h4 {font-family:monospace;font-size:14px;line-height:1.42857142857143}
  .mp h2 {font-size:16px;line-height:1.25}
  .mp h1 {font-size:20px;line-height:2}
  .mp {text-align:justify;background:#fff}
  .mp,.mp code,.mp pre,.mp pre code,.mp tt,.mp kbd,.mp samp {color:#131211}
  .mp h1,.mp h2,.mp h3,.mp h4 {color:#030201}
  .mp u {text-decoration:underline}
  .mp code,.mp strong,.mp b {font-weight:bold;color:#131211}
  .mp em,.mp var {font-style:italic;color:#232221;text-decoration:none}
  .mp a,.mp a:link,.mp a:hover,.mp a code,.mp a pre,.mp a tt,.mp a kbd,.mp a samp {color:#0000ff}
  .mp b.man-ref {font-weight:normal;color:#434241}
  .mp pre {padding:0 4ex}
  .mp pre code {font-weight:normal;color:#434241}
  .mp h2+pre,h3+pre {padding-left:0}
  ol.man-decor,ol.man-decor li {margin:3px 0 10px 0;padding:0;float:left;width:33%;list-style-type:none;text-transform:uppercase;color:#999;letter-spacing:1px}
  ol.man-decor {width:100%}
  ol.man-decor li.tl {text-align:left}
  ol.man-decor li.tc {text-align:center;letter-spacing:4px}
  ol.man-decor li.tr {text-align:right;float:right}
  </style>
</head>
<!--
  The following styles are deprecated and will be removed at some point:
  div#man, div#man ol.man, div#man ol.head, div#man ol.man.

  The .man-page, .man-decor, .man-head, .man-foot, .man-title, and
  .man-navigation should be used instead.
-->
<body id='manpage'>
  <div class='mp' id='man'>

  <div class='man-navigation' style='display:none'>
    <a href="#NAME">NAME</a>
    <a href="#DESCRIPTION">DESCRIPTION</a>
    <a href="#WHAT-IS-AN-INI-FILE">WHAT IS AN INI FILE</a>
    <a href="#SUPPORTED-SYNTAXES">SUPPORTED SYNTAXES</a>
    <a href="#READ-AN-INI-FILE">READ AN INI FILE</a>
    <a href="#BASIC-EXAMPLES">BASIC EXAMPLES</a>
    <a href="#HOW-IT-WORKS">HOW IT WORKS</a>
    <a href="#RENDERING">RENDERING</a>
    <a href="#SIZE-OF-THE-DISPATCHED-DATA">SIZE OF THE DISPATCHED DATA</a>
    <a href="#THE-IniFormat-BITFIELD">THE IniFormat BITFIELD</a>
    <a href="#THE-MODEL-FORMAT">THE MODEL FORMAT</a>
    <a href="#THE-IniStatistics-AND-IniDispatch-STRUCTURES">THE IniStatistics AND IniDispatch STRUCTURES</a>
    <a href="#FORMATTING-THE-VALUES">FORMATTING THE VALUES</a>
    <a href="#FORMATTING-THE-KEY-NAMES">FORMATTING THE KEY NAMES</a>
    <a href="#FORMATTING-THE-SECTION-PATHS">FORMATTING THE SECTION PATHS</a>
    <a href="#PERFORMANCE">PERFORMANCE</a>
  </div>

  <ol class='man-decor man-head man head'>
    <li class='tl'>libconfini</li>
    <li class='tc'>Library Functions Manual</li>
    <li class='tr'>libconfini</li>
  </ol>

  <h2 id="NAME">NAME</h2>
<p class="man-name">
  <code>libconfini</code>
</p>
<h2 id="DESCRIPTION">DESCRIPTION</h2>

<p><strong>libconfini</strong> is a simple INI parsing library with the ability to read disabled entries (i.e., valid entries nested in comments). <strong>libconfini</strong> does not store the data read from an INI file, but rather dispatches it, formatted, to a custom listener.</p>

<p>The code is written in C and does not depend on any particular library, except for the C standard libraries <strong>stdio.h</strong>, <strong>stdlib.h</strong> and <strong>stdint.h</strong>.</p>

<p>If you want to start to learn directly from the code, you can find partially self-documented sample usages of <strong>libconfini</strong> under <code>/usr/share/doc/libconfini/examples/</code>.</p>

<h2 id="WHAT-IS-AN-INI-FILE">WHAT IS AN INI FILE</h2>

<p>INI files were introduced with the early versions of Microsoft Windows, where the .ini file name extension stood for INItialization. An INI file can be considered as a string representation of a tree object, with new lines used as delimiters between nodes. A typical INI file is a plain text file looking like the following example:</p>

<pre><code class="{.ini}">
# delivery.conf

; general options

location = Colosseum
place = Rome

[sender]

name = John Smith
email = john.smith@example.com

[receiver]

name = Mario Rossi      # He's a fat guy
email = mario.rossi@example.com
</code></pre>

<h2 id="SUPPORTED-SYNTAXES">SUPPORTED SYNTAXES</h2>

<p>During the years, several interpretations of INI files appeared. In some implementation the colon character (<code>:</code>) has been adopted as delimiter (a typical example under GNU/Linux is <code>/etc/nsswitch.conf</code>), in other implementation the space (<code>/[ \t\v\f]+/</code> or <code>/(?:\\(?:\n\r?|\r\n?)|[\t \v\f])+/</code>) has been used instead (see for example <code>/etc/host.conf</code>), and so on. This library has been born as a general INI parser for GNU, so the support of most of the main INI dialects has been implemented within it.</p>

<p>Especially in Microsoft Windows, a more radical syntax variation has been implemented: the use of the semicolon, instead of new lines, as node delimiter, as in the following example:</p>

<pre><code class="{.ini}">
# delivery.conf

; general options

location = Colosseum; place = Rome; [sender] name = John Smith;
email = john.smith@example.com; [receiver] name = Mario Rossi; # He's a fat guy
email = mario.rossi@example.com
</code></pre>

<p>For several reasons the use of semicolon as node delimiter is not (and will never be) supported by <strong>libconfini</strong>.</p>

<h3 id="KEYS">KEYS</h3>

<p>A <strong>key element</strong> is identified as a string followed by a delimiter -- typically the equals sign (<code>=</code>) or the colon sign (<code>:</code>) or a space sequence (<code>/\s+/</code>) -- which is followed by a value, which is followed by a new line or an inline comment.</p>

<p>Both the <strong>key part</strong> and the <strong>value part</strong> may be enclosed within quotes (<code>'</code> or <code>"</code>):</p>

<pre><code class="{.ini}">
foo = 'bar'
"hello" = world
"artist" = "Pablo Picasso"
</code></pre>

<p>In order to avoid error exceptions, strings containing an unterminated quote will always be treated as if they had a virtual quote as their last + 1 character.</p>

<pre><code class="{.ini}">
foo = "bar
</code></pre>

<p>will always determine the same behavior as if it were</p>

<pre><code class="{.ini}">
foo = "bar"
</code></pre>

<p>The <strong>key part</strong> can contain any character, except the delimiter (which can be enclosed within quotes for not beeing considered as such). Internal new line sequences must be escaped (ECMAScript regular expression: <code>/\\(?:\n\r?|\r\n?)/</code>).</p>

<p>If the <strong>key part</strong> part is missing the element is considered of unknown type, i.e., <code>INI_UNKNOWN</code> -- see enum <code>#IniNodeType</code> -- (example: <code>= foo</code>). If the <strong>value part</strong> is missing the key element is considered empty (example: <code>foo =</code>). If the delimiter is missing, according to some formats the key element is considered to be an <em>implicit key</em> -- typically representing the boolean <code>TRUE</code> (example: <code>foo</code>). For instance, in the following example from <code>/etc/pacman.conf</code>, <code>IgnorePkg</code> is an empty key, while <code>Color</code> is an implicit key (representing a <code>TRUE</code> boolean -- i.e., <code>Color = YES</code>):</p>

<pre><code class="{.ini}">
HoldPkg = pacman glibc
Architecture = auto
IgnorePkg =
Color
SigLevel = Required DatabaseOptional
LocalFileSigLevel = Optional
</code></pre>

<p>The <strong>value</strong> part can contain typed data, usually: a boolean (booleans supported by <strong>libconfini</strong> are: <code>NO</code>/<code>YES</code>, <code>FALSE</code>/<code>TRUE</code>, <code>0</code>/<code>1</code>), a string, a number, or an array (typically with commas as members delimiters -- example: <code>paths = /etc, /usr, "/home/john/Personal Data"</code>). Internal new line sequences must be escaped (ECMAScript regular expression: <code>/\\(?:\n\r?|\r\n?)/</code>).</p>

<pre><code class="{.ini}">
[my_section]

my_string = "Hello world"
'my_number' = 42
my_boolean = NO
my_implicit_boolean
my_array = Asia, Africa, 'North America', South America,\
           Antarctica, Europe, Australia
</code></pre>

<h3 id="SECTIONS">SECTIONS</h3>

<p>A <strong>section</strong> can ben imagined like a directory. A <strong>section path</strong> is identified as the string <code>"$1"</code> in the regular expression (ECMAScript regular expression) <code>/(?:^|\n)[ \t\v\f]*\[[ \t\v\f]*([^\]]*)[ \t\v\f]*\]/</code> globally applied to an INI file. A section path expresses nesting through the 'dot' character, as in the following example:</p>

<pre><code class="{.ini}">
[section]

foo = bar

[section.subsection]

foo = bar
</code></pre>

<p>A section path starting with a dot expresses nesting to the previous section. Hence the last example is equivalent to:</p>

<pre><code class="{.ini}">
[section]

foo = bar

[.subsection]

foo = bar
</code></pre>

<p>Keys appearing before any section path belong to a virtual <em>root</em> node (with an empty string as path), as the key <code>foo</code> in the following example:</p>

<pre><code class="{.ini}">
foo = bar

[options]

interval = 3600

[host]

address = 127.0.0.1
port = 80
</code></pre>

<p>Section parts can be enclosed within quotes:</p>

<pre><code class="{.ini}">
["world".europe.'germany'.berlin]

foo = bar
</code></pre>

<h3 id="COMMENTS">COMMENTS</h3>

<p>Comments are string segments enclosed within the sequence <code>/(?:^|\s)[;#]/</code> and a new line sequence, as in the following example:</p>

<pre><code class="{.ini}">
# this is a comment

foo = bar       # this is an inline comment

; this is another comment
</code></pre>

<p>Comments can in theory be multiline, following the same syntax of multiline disabled entries (see below). This is usually of little utility, except for inline comments that you want to make sure will refer to the previous entry:</p>

<pre><code class="{.ini}">
comedy1 = The Tempest

comedy2 = Twelfth Night      #  If music be the food of love, play on;        \
                             #  Give me excess of it; that, surfeiting,       \
                             #  The appetite may sicken, and so die. --       \
                             #  That strain again; it had a dying fall:       \
                             #  O, it came oer my ear, like the sweet sound   \
                             #  That breathes upon a bank of violets,         \
                             #  Stealing, and giving odour! Enough! No more.  \
                             #  'Tis not so sweet now as it was before.       \
                             #                                                \
                             #      Orsino, scene I

# This is also a masterpiece!
comedy3 = The Merchant of Venice
</code></pre>

<h3 id="ESCAPING-SEQUENCES">ESCAPING SEQUENCES</h3>

<p>In order to maximize the flexibility of the data, only four escaping sequences are supported by <strong>libconfini</strong>: <code>\'</code>, <code>\"</code>, <code>\\</code> and the multiline escaping sequence (ECMAScript regular expression: <code>/\\(?:\n\r?|\r\n?)/</code>).</p>

<p>The first three escaping sequences are left untouched by all functions except <code>ini_unquote()</code>. Nevertheless, the characters <code>'</code>, <code>"</code> and <code>\</code> can determine different behaviors during the parsing depending on whether they are escaped or unescaped. For instance, the string <code>#johnsmith</code> in the following example will not be parsed as a comment:</p>

<pre><code class="{.ini}">
[users.jsmith]

comment = "hey! have a look at my hashtag #johnsmith !"
</code></pre>

<p>A particular case of escaping sequence is the multiline escaping sequence (<code>/\\(?:\n\r?|\r\n?)/</code>), which in multiline INI files gets <em>immediately unescaped by <strong>libconfini</strong></em>.</p>

<pre><code class="{.ini}">
foo = this\
is\
a\
multiline\
value
</code></pre>

<h3 id="DISABLED-ENTRIES">DISABLED ENTRIES</h3>

<p>A disabled entry is either a section or a key that has been nested inside a comment as its only child. Disabled entries can be multiline, using <code>/\\(?:\n\r?|\r\n?)[\t \v\f]*[;#]+/</code> as multiline escaping sequence. For example:</p>

<pre><code class="{.ini}">
#this = is\
 #a\
    #multiline\
#disabled\
  #entry
</code></pre>

<h3 id="ENCODINGS">ENCODINGS</h3>

<p>The encodings currently supported by <strong>libconfini</strong> are ASCII and UTF-8. In case the INI file is case-insensitive with respect to keys and section names, <strong>libconfini</strong> will always convert all ASCII letters to lowercase (except within values) -- <em>even when these are enclosed within quotes</em> -- but will <strong>not</strong> convert non-ASCII code points to lowercase (for instance, <code>Ā</code> will not be rendered as <code>ā</code>, but will be rather rendered verbatim). <em>In general it is a good practice to use UTF-8 within values, but to use ASCII only within keys names and sections names.</em></p>

<h2 id="READ-AN-INI-FILE">READ AN INI FILE</h2>

<p>The syntax of <strong>libconfini</strong>'s main functions is:</p>

<p>#1</p>

<pre><code class="{.c}">int load_ini_file (
    FILE * ini_file,
    IniFormat format,
    int (*f_init)(
        IniStatistics *statistics,
        void *user_data
    ),
    int (*f_foreach)(
        IniDispatch *dispatch,
        void *user_data
    ),
    void *user_data
)
</code></pre>

<p>#2</p>

<pre><code class="{.c}">int load_ini_path (
    char *path,
    IniFormat format,
    int (*f_init)(
        IniStatistics *statistics,
        void *user_data
    ),
    int (*f_foreach)(
        IniDispatch *dispatch,
        void *user_data
    ),
    void *user_data
)
</code></pre>

<p>where</p>

<ul>
<li><code>ini_file</code> in <code>load_ini_file()</code> is the <code>FILE</code> struct pointing to the INI file</li>
<li><code>path</code> in <code>load_ini_path()</code> is the path where the INI file is located (pointer to a char array, a.k.a. a "C string")</li>
<li><code>format</code> is a bitfield structure defining the syntax of the INI file (see the <code>IniFormat</code> struct)</li>
<li><code>f_init</code> is the function that will be invoked <em>before</em> any dispatching begins -- it can be <code>NULL</code></li>
<li><code>f_foreach</code> is the callback function that will be invoked for each member of the INI file - it can be <code>NULL</code></li>
<li><code>user_data</code> is a pointer to a custom argument -- it can be <code>NULL</code></li>
</ul>


<p>The function <code>f_init()</code> is invoked with two arguments:</p>

<ul>
<li><code>statistics</code> -- a pointer to an <code>IniStatistics</code> object containing some properties about the file read
(like its size in bytes and the number of its members)</li>
<li><code>user_data</code> -- a pointer to the custom argument previously passed to the <code>load_ini_file()</code> / <code>load_ini_path()</code> functions</li>
</ul>


<p>The function <code>f_foreach()</code> is invoked with two arguments:</p>

<ul>
<li><code>dispatch</code> -- a pointer to an <code>IniDispatch</code> object containing the parsed member of the INI file</li>
<li><code>user_data</code> -- a pointer to the custom argument previously passed to the <code>load_ini_file()</code> / <code>load_ini_path()</code> functions</li>
</ul>


<h2 id="BASIC-EXAMPLES">BASIC EXAMPLES</h2>

<p>#1</p>

<pre><code class="{.c}">
#include &lt;stdio.h&gt;
#include &lt;confini.h&gt;

int ini_listener (IniDispatch *dispatch, void *user_data) {

  printf("DATA: %s\nVALUE: %s\nNODE TYPE: %d\n\n", dispatch-&gt;data, dispatch-&gt;value, dispatch-&gt;type);

  return 0;

}

int main () {

  if (load_ini_path("my_file.conf", INI_DEFAULT_FORMAT, NULL, ini_listener, NULL)) {

    fprintf(stderr, "Sorry, something went wrong :-(\n");
    return 1;

  }

  return 0;

}
</code></pre>

<p>#2</p>

<pre><code class="{.c}">
#include &lt;stdio.h&gt;
#include &lt;confini.h&gt;

int ini_listener (IniDispatch *dispatch, void *user_data) {

  printf("DATA: %s\nVALUE: %s\nNODE TYPE: %d\n\n", dispatch-&gt;data, dispatch-&gt;value, dispatch-&gt;type);

  return 0;

}

int main () {

  if (load_ini_file(fopen("my_file.conf", "r"), INI_DEFAULT_FORMAT, NULL, ini_listener, NULL)) {

    fprintf(stderr, "Sorry, something went wrong :-(\n");
    return 1;

  }

  return 0;

}
</code></pre>

<h2 id="HOW-IT-WORKS">HOW IT WORKS</h2>

<p>The function <code>load_ini_path()</code> is a shortcut to the function <code>load_ini_file()</code> using a path instead of a <code>FILE</code> struct.</p>

<p>The function <code>load_ini_file()</code> dynamically allocates at once the whole INI file into the heap, and the two structures <code>IniStatistics</code> and <code>IniDispatch</code> into the stack. All the members of the INI file are then dispatched to the listener <code>f_foreach()</code>. Finally the allocated memory gets automatically freed.</p>

<p>Because of this mechanism <em>it is very important that all the dispatched data be <strong>immediately</strong> copied by the user (when needed), and no pointers to the passed data be saved</em>: after the end of the function <code>load_ini_file()</code> or <code>load_ini_path()</code> all the allocated data will be destroyed indeed.</p>

<p>Within a dispatching cycle, the structure containing each dispatch (<code>IniDispatch *dispatch</code>) is always the same <code>struct</code> that gets constantly updated with new information.</p>

<p>The strings passed with each dispatch, as already said, must not be freed. <em>Nevertheless, before being copied or analyzed they can be edited, <strong>with some precautions</strong></em>:</p>

<ol>
<li>Be sure that your edit remains within the buffer lengths given (see: <code>IniDispatch::d_len</code> and <code>IniDispatch::v_len</code>).</li>
<li>If you want to edit the content of <code>IniDispatch::data</code> and this contains a section path, the <code>IniDispatch::append_to</code> properties of its children <em>may</em> refer to the same buffer: if you edit it you can no more rely on its children's <code>IniDispatch::append_to</code> properties (you will not make any damage, the loop will continue just fine: so if you think you are going to never use the property <code>IniDispatch::append_to</code> just do it).</li>
<li>Regarding <code>IniDispatch::value</code>, the buffer will not be shared between dispatches, so feel free to edit it.</li>
<li>Regarding <code>IniDispatch::append_to</code>, this buffer is likely to be shared with other dispatches: again, you will not destroy the world nor generate errors, but you will make the next <code>IniDispatch::append_to</code>s useless. Therefore, <strong>the property <code>IniDispatch::append_to</code> should be considered read-only</strong> -- this is just a logical imposition (and this is why <code>IniDispatch::append_to</code> is not passed as <code>const</code>).</li>
</ol>


<p>Typical peaceful edits are the calls of the functions <code>ini_collapse_array()</code> and <code>ini_unquote()</code> directly on the buffer <code>IniDispatch::value</code> (but make sure that you are not going to edit the global string <code>#INI_IMPLICIT_VALUE</code>):</p>

<pre><code class="{.c}">
#include &lt;stdio.h&gt;
#include &lt;confini.h&gt;

int ini_listener (IniDispatch *dispatch, void *user_data) {

  if (dispatch-&gt;type == INI_KEY || dispatch-&gt;type == INI_DISABLED_KEY) {

    ini_unquote(dispatch-&gt;value, dispatch-&gt;format);

  }

  printf("DATA: %s\nVALUE: %s\n", dispatch-&gt;data, dispatch-&gt;value);

  return 0;

}

int main () {

  if (load_ini_path("my_file.ini", INI_DEFAULT_FORMAT, NULL, ini_listener, NULL)) {

    fprintf(stderr, "Sorry, something went wrong :-(\n");
    return 1;

  }

  return 0;

}
</code></pre>

<p>In order to set the value to be assigned to implicit keys, please use the <code>ini_set_implicit_value()</code> function. A <em>zero-length <code>TRUE</code>-boolean</em> is usually a good choice:</p>

<pre><code class="{.c}">
/* void ini_set_implicit_value (char * implicit_value, unsigned long int implicit_v_len); */

ini_set_implicit_value("YES", 0);
</code></pre>

<p>Alternatively, instead of <code>ini_set_implicit_value()</code> you can manually define at the beginning of your code the two global variables <code>#INI_IMPLICIT_VALUE</code> and <code>#INI_IMPLICIT_V_LEN</code>, which will be retrieved by <strong>libconfini</strong>:</p>

<pre><code class="{.c}">
#include &lt;confini.h&gt;

char *INI_IMPLICIT_VALUE = "YES";
unsigned long int INI_IMPLICIT_V_LEN = 3;
</code></pre>

<p>If not defined elsewhere, these variables are respectively <code>NULL</code> and <code>0</code> by default.</p>

<p>After having set the value to be assigned to implicit key elements, it is possible to test whether a dispatched key is implicit or not by comparing the address of its <code>value</code> property with the global variable <code>#INI_IMPLICIT_VALUE</code>:</p>

<pre><code class="{.c}">
#include &lt;stdio.h&gt;
#include &lt;confini.h&gt;

#define NO 0
#define YES 1

int ini_listener (IniDispatch *dispatch, void *user_data) {

  if (dispatch-&gt;value == INI_IMPLICIT_VALUE) {

    printf(
      "\nDATA: %s\nVALUE: %s\n(This is an implicit key element)\n",
      dispatch-&gt;data, dispatch-&gt;value
    );

  } else {

    printf("\nDATA: %s\nVALUE: %s\n", dispatch-&gt;data, dispatch-&gt;value);

  }

  return 0;

}

int main () {

  IniFormat my_format;

  ini_set_implicit_value("[implicit default value]", 0);

  /* Without setting this, implicit keys will be anyway considered empty: */
  my_format.implicit_is_not_empty = YES;

  if (load_ini_path("my_file.conf", my_format, NULL, ini_listener, NULL)) {

    fprintf(stderr, "Sorry, something went wrong :-(\n");
    return 1;

  }

  return 0;

}
</code></pre>

<h2 id="RENDERING">RENDERING</h2>

<p>The output strings dispatched by <strong>libconfini</strong> will follow some formatting rules depending on their role within the INI file. First, the multiline sequences will be unescaped, then</p>

<ul>
<li><strong>Section paths</strong> will be rendered according to ECMAScript <code>section_name.replace(/\.*\s*$|(?:\s*(\.))+\s*|^\s+/g, "$1").replace(/\s+/g, " ")</code> -- within single or double quotes, if active, the text will be rendered verbatim</li>
<li><strong>Key names</strong> will be rendered according to ECMAScript <code>key_name.replace(/^[\n\r]\s*|\s+/g, " ")</code> -- within single or double quotes, if active, the text will be rendered verbatim</li>
<li><strong>Values</strong>, if <code>format.do_not_collapse_values</code> is active, will be cleaned of spaces at the beginning and at the end, otherwise will be rendered though the same algorithm used for key names.</li>
<li><strong>Comments</strong>: if multiline, ECMAScript <code>comment_string.replace(/(^|\n\r?|\r\n?)[ \t\v\f]*[#;]+/g, "$1")</code>; otherwise, ECMAScript <code>comment_string.replace(/^[ \t\v\f]*[#;]+/, "")</code>.</li>
<li><strong>Unknown nodes</strong> will be rendered verbatim.</li>
</ul>


<h2 id="SIZE-OF-THE-DISPATCHED-DATA">SIZE OF THE DISPATCHED DATA</h2>

<p>Within an INI file it is granted that if one sums together all the <code>(dispatch-&gt;d_len + 1)</code> and all the <code>(dispatch-&gt;v_len + 1)</code> > 1 received, the result will always be less-than or equal-to <code>statistics-&gt;bytes</code> (where <code>+ 1</code> represents the NUL terminators). <strong>If one adds to this also all the <code>dispatch-&gt;at_len</code> properties, or if the <code>dispatch-&gt;v_len</code> properties of implicit keys are non-zero, the sum may exceed it.</strong> This can be relevant or irrelevant depending on your code.</p>

<pre><code class="{.c}">
#include &lt;stdio.h&gt;
#include &lt;confini.h&gt;

struct size_check {
  unsigned long int bytes, buff_lengths;
};

int ini_init (IniStatistics *stats, void *other) {

  ((struct size_check *) other)-&gt;bytes = stats-&gt;bytes;
  ((struct size_check *) other)-&gt;buff_lengths = 0;
  return 0;

}

int ini_listener (IniDispatch *this, void *other) {

  ((struct size_check *) other)-&gt;buff_lengths += this-&gt;d_len + 1 + (this-&gt;v_len ? this-&gt;v_len + 1 : 0);
  return 0;

}

int main () {

  struct size_check check;

  if (load_ini_path("my_file.ini", INI_DEFAULT_FORMAT, ini_init, ini_listener, &amp;check)) {

    fprintf(stderr, "Sorry, something went wrong :-(\n");
    return 1;

  }

  printf(

    "The file is %d bytes large.\n\nThe sum of the lengths of all "
    "IniDispatch::data buffers plus the lengths of all non-empty "
    "IniDispatch::value buffers is %d.\n",

    check.bytes, check.buff_lengths

  );

  /* `INI_IMPLICIT_V_LEN` is 0 and is not even used, so this cannot happen: */

  if (check.buff_lengths &gt; check.bytes) {

    fprintf(stderr, "The end is near!");
    return 1;

  }

  return 0;

}
</code></pre>

<h2 id="THE-IniFormat-BITFIELD">THE <code>IniFormat</code> BITFIELD</h2>

<p>For a correct use of this library it is fundamental to understand the <code>IniFormat</code> bitfield. <strong>libconfini</strong> has been born as a general INI parser, with the main purpose of <em>being able to understand INI files written by other programs</em> (see README). Therefore some flexibility was required.</p>

<p>When an INI file is parsed it is parsed according to a format. The <code>IniFormat</code> bitfield is a description of such format.</p>

<p>Each format can be represented also as a univocal 24-bit unsigned integer. In order to convert an <code>IniFormat</code> to an unsigned integer and vice versa please see <code>ini_format_get_id()</code>, <code>ini_format_set_to_id()</code> and <code>#IniFormatId</code>.</p>

<h2 id="THE-MODEL-FORMAT">THE MODEL FORMAT</h2>

<p>A model format named <code>INI_DEFAULT_FORMAT</code> is available.</p>

<pre><code class="{.c}">
IniFormat my_format;

my_format = INI_DEFAULT_FORMAT;
</code></pre>

<p>The code above corresponds to:</p>

<pre><code class="{.c}">
#define NO 0
#define YES 1

IniFormat my_format;

my_format.delimiter_symbol = INI_EQUALS;
my_format.semicolon = INI_PARSE_COMMENT;
my_format.hash = INI_PARSE_COMMENT;
my_format.multiline_entries = INI_EVERYTHING_MULTILINE;
my_format.case_sensitive = NO;
my_format.no_spaces_in_names = NO;
my_format.no_single_quotes = NO;
my_format.no_double_quotes = NO;
my_format.implicit_is_not_empty = NO;
my_format.do_not_collapse_values = NO;
my_format.no_disabled_after_space = NO;
my_format.disabled_can_be_implicit = NO; 
</code></pre>

<h2 id="THE-IniStatistics-AND-IniDispatch-STRUCTURES">THE <code>IniStatistics</code> AND <code>IniDispatch</code> STRUCTURES</h2>

<p>When the function <code>load_ini_file()</code> / <code>load_ini_path()</code> reads an INI file, it dispatches the file content to the <code>f_foreach()</code> listener. Before the dispatching begins some statistics about the parsed file can be dispatched to the <code>f_init()</code> listener (if this is non-<code>NULL</code>).</p>

<p>The information passed to <code>f_init()</code> is passed through an <code>IniStatistics</code> structure, while the information passed to <code>f_foreach()</code> is passed through an <code>IniDispatch</code> structure.</p>

<h2 id="FORMATTING-THE-VALUES">FORMATTING THE VALUES</h2>

<p>Once your listener starts to receive the parsed data you may want to parse and better format the <code>value</code> part of key elements. The following functions may be useful for this purpose:</p>

<ul>
<li><code>ini_unquote()</code></li>
<li><code>ini_array_get_length()</code></li>
<li><code>ini_collapse_array()</code></li>
<li><code>ini_array_foreach()</code></li>
<li><code>ini_split_array()</code></li>
<li><code>ini_get_bool()</code></li>
<li><code>ini_get_lazy_bool()</code></li>
</ul>


<p>Together with the functions listed above the following links are available, in case you don't want to <code>#include &lt;stdlib.h&gt;</code> in your source:</p>

<ul>
<li><code>ini_get_int()</code> = <a href="http://www.gnu.org/software/libc/manual/html_node/Parsing-of-Integers.html#index-atoi"><code>atoi()</code></a></li>
<li><code>ini_get_lint()</code> = <a href="http://www.gnu.org/software/libc/manual/html_node/Parsing-of-Integers.html#index-atol"><code>atol()</code></a></li>
<li><code>ini_get_llint()</code> = <a href="http://www.gnu.org/software/libc/manual/html_node/Parsing-of-Integers.html#index-atoll"><code>atoll()</code></a></li>
<li><code>ini_get_float()</code> = <a href="http://www.gnu.org/software/libc/manual/html_node/Parsing-of-Integers.html#index-atof"><code>atof()</code></a></li>
</ul>


<h2 id="FORMATTING-THE-KEY-NAMES">FORMATTING THE KEY NAMES</h2>

<p>The function <code>ini_unquote()</code> may be useful for key names enclosed within quotes.</p>

<h2 id="FORMATTING-THE-SECTION-PATHS">FORMATTING THE SECTION PATHS</h2>

<p>In order to retrieve the parts of a section path the functions <code>ini_array_get_length()</code>, <code>ini_array_foreach()</code> and <code>ini_split_array()</code> can be used with '.' as delimiter. Note that section paths dispatched by <strong>libconfini</strong> are <em>always</em> collapsed arrays, therefore calling the function <code>ini_collapse_array()</code> on them will have no effects.</p>

<p>It may be required that the function <code>ini_unquote()</code> be applied to each part of a section path, depending on the content and the format of the INI file.</p>

<h2 id="PERFORMANCE">PERFORMANCE</h2>

<p>The the algorithms used by <strong>libconfini</strong> stand in a delicate equilibrium between flexibility, speed and code readability, with flexibility as primary target. Performance can vary with the format used for parsing an INI file, but in most of the cases is not a concern.</p>

<p>One can measure the performance of the library by doing something like:</p>

<pre><code class="{.c}">
/* Please create an INI file large enough and call it "big_ini_file.conf" */

#include &lt;stdio.h&gt;
#include &lt;confini.h&gt;
#include &lt;time.h&gt;

static int get_ini_size (IniStatistics *statistics, void *user_data) {
  *((unsigned long int *) user_data) = statistics-&gt;bytes;
  return 0;
}

static int empty_listener (IniDispatch *dispatch, void *user_data) {
  return 0;
}

int main () {
  unsigned long int bytes;
  double seconds;
  clock_t start, end;
  IniFormat my_format = INI_DEFAULT_FORMAT;
  start = clock();
  if (load_ini_path("big_ini_file.conf", my_format, get_ini_size, empty_listener, &amp;bytes)) {
    return 1;
  }
  end = clock();
  seconds = (end - start) / (double) CLOCKS_PER_SEC;
  printf(
    "%d bytes parsed in %f seconds.\n"
    "Number of bytes parsed per second: %f\n",
    bytes, seconds, bytes / seconds
  );
  return 0;
}
</code></pre>

<p>By changing the properties of the variable <code>my_format</code> on the code above you may obtain different results.</p>

<p>On my old laptop <strong>libconfini</strong> seems to parse around 20 MB per second using the model format <code>INI_DEFAULT_FORMAT</code>. Whether this is enough for you or not, that depends on your needs.</p>

<pre><code>
54692353 bytes parsed in 2.692092 seconds.
Number of bytes parsed per second: 20315930.139089
</code></pre>


  <ol class='man-decor man-foot man foot'>
    <li class='tl'>madmurphy</li>
    <li class='tc'>September 2017</li>
    <li class='tr'>libconfini</li>
  </ol>

  </div>
</body>
</html>
